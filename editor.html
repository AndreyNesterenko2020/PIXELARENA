<!DOCTYPE monkeyland>
<html>
  <head>
    <title>Pixel Arena Map Editor</title>
    <script src="js/THREE.js"></script>
    <script src="js/EditorControls.js"></script>
    <script src="js/FirstPersonControls.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/jszip.js"></script>
    <script src="js/map_utilities.js"></script>
    <style>
      @font-face {
        font-family: BlockBuilder3D;
        src: url("assets/font/BlockBuilder3D.ttf");
      }
      #buttons {
        width: 101%;
        border: solid black 1px;
        margin-left: -8px;
        margin-top: -8px;
        background-image: url("assets/textures/UI/button2.png");
      }
      #tabs {
        width: 101%;
        border: solid black 1px;
        margin-left: -8px;
        margin-top: -1px;
        background-image: url("assets/textures/UI/button2.png");
        background-size: 100% 100%;
        display: flex;
      }
      body {
        font-family: BlockBuilder3D;
        overflow: hidden;
        user-select: none;
        height: 100%;
      }
      button:hover {
        filter: brightness(50%);
      }
      button {
        font-family: blockbuilder3D;
        background-color: white;
        /*position: fixed;*/
        border: none;
        background-image: url("assets/textures/UI/button.png");
        background-size: 100% 100%;
      }
      .tab {
        background-image: url("assets/textures/UI/tab1.png");
        background-size: 100% 100%;
        width: 130px;
        height: 40px;
        text-align: center;
        cursor: pointer;
      }
      .tab:hover {
        filter: brightness(60%);
      }
      .clicked {
        filter: brightness(50%);
      }
      #main {
        height: 90%;
      }
      #selection {
        position: fixed;
        border: solid rgb(155, 181, 209, 1) 4px;
        background-color: rgb(155, 181, 209, 0.5);
        display: none;
        pointer-events: none;
      }
      .UIelement {
        background-image: url("assets/textures/UI/button2.png");
        background-size: 100% 100%;
        border: solid black 1px;
        filter: brightness(85%);
      }
      .contextmenu {
        position: fixed;
        width: 10%;
        z-index: 100;
        background-image: url("assets/textures/UI/button2.png");
        background-size: 100% 100%;
        box-shadow: 5px 5px 1px #525252;
        display: none;
      }
      .contextmenu > div > a {
        margin-left: 10%;
        margin-top: 2%;
        width: 90%;
      }
      .contextmenu > div:first-child {
        margin-top: 5%;
      }
      .contextmenu > div:last-child {
        margin-bottom: 4%;
      }
      .contextmenu > div:hover {
        background-color: #636363;
      }
      window {
        background-size: 100% 100%;
        background-color: d9d9d9;
        border: solid black 1px;
        position: fixed;
      }
      windowHeader {
        background-image: url("assets/textures/UI/button2.png");
        background-size: 100% 100%;
        border: solid black 1px;
        margin: -1;
        width: 100%;
        height: 30px;
        position: absolute;
        text-align: center;
      }
    </style>  
  </head>
  <body onbeforeunload="return true">
    <div id="selection"></div>
    <input type="file" id="fileUploader" style="display: none;">
    <a download id="fileDownloader" style="display: none;">
    <div class="contextmenu">
      <div onclick="if(this.parentElement.target.tagName != 'IMG'){editor.undoableDeleteObject(editor.selected)}else{var this_ = this; var texture = editor.TEXTURES.find(function(a) {return a.name == this_.parentElement.target.parentElement.children[1].innerHTML});delete editor.MAP_DATA.assets[this_.parentElement.target.parentElement.children[1].innerHTML]; editor.TEXTURES.splice(editor.TEXTURES.indexOf(texture), 1)}"><a>Delete</a></div>
      <div onclick="document.getElementsByClassName('UIElement')[1].children[2].children[1].focus();"><a>Rename</a></div>
      <div onclick="editor.triggerCopy();"><a>Copy</a></div>
    </div>
    <div class="contextmenu" id="dropdown.file" style="top: 2.5%; left: 0%; width: 12%">
      <div onclick="location.reload();"><a>New</a></div>
      <div onclick="editor.triggerOpen();"><a>Open...</a></div>
      <div onclick="editor.triggerSave();"><a>Save</a></div>
      <div onclick="editor.SAVE(2);"><a>Export</a></div>
      <div onclick="editor.getUpload(function(e){e[0].name.split('.')[1] == 'MAP' && editor.LOAD(e[0], 1) || editor.LOAD(e[0], 3)}, 'map,.zip');"><a>Import from computer</a></div>
      <div onclick="editor.getFileFromGame('MAP', 'assets/maps', function(e){editor.LOAD(e, 2)}, 'map');"><a>Import from game</a></div>
    </div>
    <div class="contextmenu" id="dropdown.edit" style="top: 2.5%; left: 2%">
      <div onclick="new editor.Command(function(){editor.deleteObject(this.obj);}, function(){this.obj = editor.createObject();editor.select([this.obj]);editor.hideTool = false;});"><a>Add cube object</a></div>
      <div onclick="new editor.Command(function(){editor.deleteObject(this.obj);}, function(){this.obj = editor.createObject(false, 'spawn');[this.obj.INVISIBLE,this.obj.COLLIDABLE,this.obj.unHittable] = [true, false, true];editor.select([this.obj]);editor.hideTool = false;});"><a>Add spawn object</a></div>
      <div onclick="editor.undoableDeleteObject(editor.selected);editor.hideTool = true;"><a>Delete</a></div>
      <div onclick="document.getElementsByClassName('UIElement')[1].children[2].children[1].focus();"><a>Rename</a></div>
      <div onclick="editor.triggerCopy();"><a>Copy</a></div>
      <div onclick="editor.triggerUndo();"><a>Undo</a></div>
      <div onclick="editor.triggerRedo();"><a>Redo</a></div>
    </div>
    <div class="contextmenu" id="dropdown.view" style="top: 2.5%; left: 4%; width: 18%">
      <div onclick="this.children[0].children[0].checked=!this.children[0].children[0].checked;editor.options.renderSky=!this.children[0].children[0].checked;editor.setMode(editor.MODE);"><a><input type="checkbox" onclick="this.parentElement.parentElement.click();"></input>Render sky only in skybox editor</a></div>
      <div onclick="this.children[0].children[0].checked=!this.children[0].children[0].checked;editor.options.renderInvisible=this.children[0].children[0].checked;"><a><input type="checkbox" checked></input>Render invisible objects</a></div>
    </div>
    <div class="contextmenu" id="dropdown.help" style="top: 2.5%; left: 7%">
      <div onclick="editor.triggerHelp();"><a>Get help...</a></div>
    </div>
    <div class="contextmenu" id="dropdown.texture" style="bottom: 32.5%; right: 21.25%; width: 15%">
      <div onclick="editor.getUpload(function(e){var a = new FileReader(); a.readAsDataURL(e[0]); a.onload=function(e2){editor.MAP_DATA.assets[e[0].name.split('.')[0]]=a.result;editor.processImage(e)}}, 'png');"><a>Import from computer</a></div>
      <div onclick="editor.getFileFromGame('png', 'assets/textures', function(e){editor.createTexture(e, e.split(e.includes('textures/map') && 'assets/textures/map/' || e.includes('assets/maps/') && 'assets/maps/' || 'assets/textures/')[1].split('.')[0])});"><a>Import from game</a></div>
    </div>
    <div id="top">
      <div id="buttons">
        <button class="dropdown" name="file">File</button><button class="dropdown" name="edit">Edit</button><button class="dropdown" name="view">View</button><button class="dropdown" name="help">Help</button>
      </div>
      <div id="tabs">
        <div class="tab" id="mode_map"><br>Map editor</div>
        <div class="tab" id="mode_bound"><br>Bound editor</div>
        <div class="tab" id="mode_skybox"><br>Skybox editor</div>
        <div class="tab" id="mode_play"><br>Play test</div>
      </div>
    </div>
    <div id="main"></div>
    <script>
      //initialize THREE.js
      var scene = new THREE.Scene();
      var renderer = new THREE.WebGLRenderer();
      var camera = new THREE.PerspectiveCamera();
      camera.position.set(0, 2, -4)
      var geometry = new THREE.BoxGeometry();
      scene.background = new THREE.Color(0xffffff);
      var textureLoader = new THREE.TextureLoader();
      var PointerLockControls = new THREE.PointerLockControls(camera, renderer.domElement);
      var FirstPersonControls = new THREE.FirstPersonControls(camera, renderer.domElement);
      FirstPersonControls.movementSpeed = 5;
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var loader = new THREE.GLTFLoader();
      var light = new THREE.AmbientLight("white", 1);
      scene.add(light);
      
      //map editor logic
      var editor = {};
      editor.delta = 0;
      editor.lastUpdate = 0;
      editor.MODE = "";
      editor.MODES = {};
      editor.TEXTURES = [{fake: true, name: "<none>"}];
      editor.hideTool = false;
      editor.options = {
        selectionXray: false,
        renderSky: true,
        renderInvisible: true,
      }
      editor.main = document.getElementById("main");
      editor.top = document.getElementById("top");
      editor.rectangularSelection = document.getElementById("selection");
      editor.rectangularSelectionStartX = 0;
      editor.rectangularSelectionStartY = 0;
      editor.rectangularSelectionActive = false;
      editor.objects = [];
      editor.selected = [];
      editor.MAP_DATA = {
        assets: {},
        map: {
          skybox: [],
          boundaries: [Infinity, -Infinity, Infinity, -Infinity, Infinity, -Infinity]
        }
      }
      editor.currentFileName = "";
      editor.history = {};
      editor.selectionGroup = new THREE.Object3D();
      scene.add(editor.selectionGroup);
      
      editor.setMode = function (mode) {
        try {
          if(editor.options.renderSky) {
            loadSky(...editor.MAP_DATA.map.skybox);
          } else {
            resetSky();
          }
        } catch (e) {resetSky();}
        editor.main.innerHTML = "";
        editor.MODE = mode;
        editor.MODES[mode](editor.main);
        for(var i = 0; i < document.getElementsByClassName("tab").length; i++) {
          document.getElementsByClassName("tab")[i].className = "tab";
        }
        document.getElementById("mode_"+mode).className = "tab clicked";
      }
      
      editor.resetRectangualSelection = function () {
        editor.rectangularSelection.style.width = 0;
        editor.rectangularSelection.style.height = 0;
        editor.rectangularSelectionStartX = 0;
        editor.rectangularSelectionStartY = 0;
        editor.rectangularSelection.style.display = "none";
      }
      
      editor.setRectangularSelection = function (x, y) {
        editor.rectangularSelectionStartX = x;
        editor.rectangularSelectionStartY = y;
        editor.rectangularSelection.style.left = x;
        editor.rectangularSelection.style.top = y;
      }
      
      editor.resizeRectangularSelection = function (x, y) {
        editor.rectangularSelection.style.display = "block";
        var width = x - editor.rectangularSelectionStartX;
        var height = y - editor.rectangularSelectionStartY;
        editor.rectangularSelection.style.width = Math.abs(width);
        editor.rectangularSelection.style.height = Math.abs(height);
        if(width < 0) {
          editor.rectangularSelection.style.left = editor.rectangularSelectionStartX+width;
        }
        if(height < 0) {
          editor.rectangularSelection.style.top = editor.rectangularSelectionStartY+height;
        }
      }
      
      editor.processRectangularSelection = function (shift) {
        var width = Number(editor.rectangularSelection.style.width.split("px")[0]);
        var height = Number(editor.rectangularSelection.style.height.split("px")[0]);
        var x = Number(editor.rectangularSelection.style.left.split("px")[0]);
        var y = Number(editor.rectangularSelection.style.top.split("px")[0]);
        if(width, height == 0) {
          return;
        }
        var objects = [];
        if(!shift) {
          editor.undoableDeselect(editor.objects);
        }
        var selected = [];
        editor.objects.forEach(function (e) {
          var object_position = new THREE.Vector3();
          object_position.setFromMatrixPosition(e.matrixWorld);
          var position = editor.worldToScreen(object_position);
          if(position.x+renderer.domElement.getBoundingClientRect().x >= x && position.x <= x+width && position.y+renderer.domElement.getBoundingClientRect().y >= y && position.y+renderer.domElement.getBoundingClientRect().y <= y+height) {
            raycaster.set(camera.position, new THREE.Vector3().subVectors(object_position, camera.position).normalize());
            var result = raycaster.intersectObjects(editor.objects);
            if(result[0] && result[0].object == e || editor.options.selectionXray) {
              selected.push(e);
            }
          }
        });
        editor.undoableSelect(selected);
        editor.resetRectangualSelection();
        
        //tool visibility
        editor.hideTool = !editor.selected.length;
          
        return objects;
      }
      
      editor.createObject = function (pos, type) {
        var object = new THREE.Mesh(editor.object_types[type] && editor.object_types[type].geometry || geometry, editor.object_types[type] && editor.object_types[type].material.clone() || new THREE.MeshBasicMaterial({alphaTest: 0.95}));
        scene.add(object);
        pos && object.position.set(pos.x, pos.y, pos.z);
        editor.objects.push(object);
      
        var selectionMaterial = new THREE.LineBasicMaterial({depthTest: false, side: THREE.BackSide, color: "#ffff00"});
        object.selection = new THREE.LineSegments(new THREE.EdgesGeometry(object.geometry), selectionMaterial);
        object.selection.visible = false;
        object.selection.matrixAutoUpdate = false;
        scene.add(object.selection);
        
        object.COLLIDABLE = true;
        object.MATERIAL = "concrete";
        object.TEXTURE = "";
        object.INVISIBLE = false;
        object.unHittable = false;
        object.COLOR = "#555555";
        object.TEXTURE_STRETCH = [1, 1];
        object.name = type || "box";
        object.type = type || "box";
        
        return object;
      }
      
      editor.deleteObject = function (obj) {
        var objects = obj.concat && obj.concat() || obj;
        if(obj.uuid) {
          objects = [obj];
        }
        editor.deselect(objects);
        objects.forEach(function (object) {
          if(editor.objects.indexOf(object) != -1) {
              editor.objects.splice(editor.objects.indexOf(object), 1);
              object.removeFromParent();
              object.selection.removeFromParent();
          }
        });
        return true;
      }
      
      editor.createTexture = function (src, name) {
        if(editor.TEXTURES.find(function (a) {return a.name == name})) {return editor.TEXTURES.find(function (a) {return a.name == "src"})}
        
        var map = textureLoader.load(src);
        map.src = src;
        map.name = name;
        editor.TEXTURES.push(map);
        
        return map;
      }
      
      editor.worldToScreen = function (pos) {
        var vector = new THREE.Vector3(pos.x, pos.y, pos.z);
        vector.project(camera);

        var widthHalf = renderer.domElement.clientWidth / 2;
        var heightHalf = renderer.domElement.clientHeight / 2;

        vector.x = (vector.x * widthHalf) + widthHalf;
        vector.y = - (vector.y * heightHalf) + heightHalf;
        vector.z = 0;
        
        return new THREE.Vector2(vector.x, vector.y);
      }
      
      editor.recomputeSelection = function () {
        //reset position
        editor.selectionGroup.position.set(0,0,0);
        editor.selectionGroup.rotation.set(0,0,0);
        editor.selectionGroup.scale.set(1,1,1);
        
        //readjust selection group position to the average
        var total = new THREE.Vector3();

        editor.selected.forEach(function (object) {
          total.add(new THREE.Vector3().setFromMatrixPosition(object.matrixWorld));
        });
        
        //update origin point of selection
        total.set(total.x/editor.selected.length||0, total.y/editor.selected.length||0, total.z/editor.selected.length||0);
        editor.selectionGroup.position.copy(total);
        
        //update object position
        editor.selected.forEach(function (object) {
          object.position.set(object.position.x - total.x, object.position.y - total.y, object.position.z - total.z);
        });
      }
      
      editor.toWorld = function (object) {
        //update position
        object.position.setFromMatrixPosition(object.matrixWorld);
        
        //update rotation
        var rotation = new THREE.Quaternion();
        object.getWorldQuaternion(rotation)
        object.quaternion.copy(rotation);
        
        //update scale
        object.scale.setFromMatrixScale(object.matrixWorld);
      }
      
      editor.select = function (objects) {
        //remove all objects from selection group
        editor.selected.forEach(function (object) {
          scene.add(object);
          editor.toWorld(object);
        });
      
        //update selection
        objects.forEach(function (object) {
          if(!editor.selected.includes(object)) {
            editor.selected.push(object);
            object.selection.visible = true;
          }
        });
        
        //parent all selected objects to selection group
        editor.selected.forEach(function (object) {
            editor.selectionGroup.add(object);
        });
        
        //update selection group
        editor.recomputeSelection();
      }
      
      editor.deselect = function (objects) {
        //remove all objects from selection group
        editor.selected.forEach(function (object) {
          editor.toWorld(object);
          scene.add(object);
        });
        
        //remove deselected objects
        objects.forEach(function (object) {
          if(editor.selected.includes(object)) {
            editor.selected.splice(editor.selected.indexOf(object), 1);
            object.selection.visible = false;
          }
        });
        
        //parent all selected objects to selection group
        editor.selected.forEach(function (object) {
            editor.selectionGroup.add(object);
        });
        
        //update selection group
        editor.recomputeSelection();
      }
      
      editor.selectionApplyTransforms = function () {
        //apply selection transformations without deselecting
        //remove all objects from selection group
        editor.selected.forEach(function (object) {
          editor.toWorld(object);
          scene.add(object);
        });
        
        //parent all selected objects to selection group
        editor.selected.forEach(function (object) {
            editor.selectionGroup.add(object);
        });
        
        //update selection group
        editor.recomputeSelection();
        
        //hide tool
        editor.hideTool = true;
        
        setTimeout(function(){
          //remove all objects from selection group
          editor.selected.forEach(function (object) {
            scene.add(object);
            editor.toWorld(object);
          });
          
          //parent all selected objects to selection group
          editor.selected.forEach(function (object) {
              editor.selectionGroup.add(object);
          });
          
          //update selection group
          editor.recomputeSelection();
          
          //show tool
          editor.hideTool = false;
        },30)
      }
      
      editor.undoableSelect = function (object) {
        var old_selected = editor.selected.concat();
        new editor.Command(function(){editor.deselect(editor.selected.concat());editor.select(old_selected);/*tool visibility*/editor.hideTool = !editor.selected.length;},function(){editor.select(object);/*tool visibility*/editor.hideTool = !editor.selected.length;});
      }
      
      editor.undoableDeselect = function (object) {
        var old_selected = editor.selected.concat();
        new editor.Command(function(){editor.select(old_selected);/*tool visibility*/editor.hideTool = !editor.selected.length;},function(){editor.deselect(object.concat());/*tool visibility*/editor.hideTool = !editor.selected.length;});
      }
      
      editor.undoableDeleteObject = function (object) {
        new editor.Command(function(){this.object.forEach(function(object){editor.objects.push(object);scene.add(object);scene.add(object.selection);editor.select([object]);});}, function(){this.object=object.concat();editor.deleteObject(this.object);editor.hideTool = !editor.selected.length});
      }
      
      editor.undoableAttributechange = function (object, attr, val, refresh) {
        new editor.Command(function(){var this_=this;eval("object."+attr+"=this_.old");refresh&&editor.setMode(editor.MODE)}, function(){var this_=this;eval("this_.old=object."+attr+";object."+attr+" = val");refresh&&editor.setMode(editor.MODE)});
      }
      
      editor.updateUI = function () {
        //clean up after bound editor
        editor.MODE != "bound" && editor.boundObject && editor.deleteObject(editor.boundObject) && delete(editor.boundObject);
        //different modes
        if(editor.MODE == "map") {
          //objects list
          if(document.getElementById("object_list").children.length < editor.objects.length) {
            document.getElementById("object_list").innerHTML += "<div style='' onclick='if(!event.shiftKey){editor.deselect(editor.selected)};editor.select([this.object]);editor.hideTool = !editor.selected.length;'><div style='margin-left:14%;'><img src='assets/textures/editor/object.png' width=16><a>cube</a></div></div>";
          }
          if(document.getElementById("object_list").children.length > editor.objects.length) {
            document.getElementById("object_list").children[document.getElementById("object_list").children.length-1].outerHTML = "";
          }
          editor.objects.forEach(function (object, index) {
            if(!document.getElementById("object_list").children[index]) {
              return;
            }
            document.getElementById("object_list").children[index].style = object.selection.visible&&"background-color: gray"||"";
            document.getElementById("object_list").children[index].children[0].children[1].innerText = object.name;
            document.getElementById("object_list").children[index].contextMenu = true;
            document.getElementById("object_list").children[index].object = object;
          });
          //inspector
          document.getElementsByClassName("UIElement")[1].children[2].style.display = editor.selected.length && "block" || "none";
          
          //name attribute
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[1]) {
            editor.selected[0].name = document.getElementsByClassName("UIElement")[1].children[2].children[1].value;
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[1].value = editor.selected.length && editor.selected[0].name;
          }
          
          //texture attribute
          document.getElementById("texture_list").onchange = function () {
            editor.undoableAttributechange(editor.selected[0], "TEXTURE", this.value);
          }
          if(document.getElementById("texture_list").children.length < editor.TEXTURES.length) {
            document.getElementById("texture_list").innerHTML += "<option value='"+editor.TEXTURES[document.getElementById("texture_list").children.length].name+"'>"+editor.TEXTURES[document.getElementById("texture_list").children.length].name.replace("<","&lt")+"</option>";
            document.getElementById("texture_list_large").innerHTML += !editor.TEXTURES[document.getElementById("texture_list").children.length-1].fake && "<div style='float: left; text-align: center; max-width: 96px; overflow: hidden'><img src='"+editor.TEXTURES[document.getElementById("texture_list").children.length-1].src+"' width=64 height=64></img><figcaption>"+editor.TEXTURES[document.getElementById("texture_list").children.length-1].name.replace("<","&lt")+"</figcaption></div>" || "";
            for(var i = 0; i < document.getElementById("texture_list_large").children.length; i++) document.getElementById("texture_list_large").children[i].contextMenu = true;
          }
          if(document.getElementById("texture_list").children.length > editor.TEXTURES.length) {
            for(var i = 0; i < document.getElementById("texture_list").children.length; i++) {
              if(!editor.TEXTURES.find(function(a) {return editor.selected[0] && a.name == document.getElementById("texture_list_large").children[i].children[1].innerHTML})) {
                break;
              }
            }
            document.getElementById("texture_list").children[i+1].outerHTML = "";
            document.getElementById("texture_list_large").children[i].outerHTML = "";
          }
          document.getElementById("texture_list").value = editor.selected[0] && editor.selected[0].TEXTURE || "<none>";
          var texture = editor.TEXTURES.find(function(a) {return editor.selected[0] && a.name == editor.selected[0].TEXTURE}) || editor.TEXTURES[0];
          if(!texture.fake && editor.object_types[editor.selected[0].type] && editor.object_types[editor.selected[0].type].textured) {
            editor.selected[0].material.map = texture;
          } else {
            if(editor.selected[0] && editor.selected[0].material.map) editor.selected[0].material.map = undefined;
          }
          
          //do not continue if no selected object
          if(!editor.selected.length) return;
          
          //position
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[5].children[0]) {
            editor.selected[0].position.x = (Number(document.getElementsByClassName("UIElement")[1].children[2].children[5].children[0].value) - editor.selectionGroup.position.x + 1 || editor.selected[0].position.x + 1) - 1;
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[5].children[0].value = editor.selected.length && editor.selected[0].getWorldPosition(new THREE.Vector3).x;
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[5].children[1]) {
            editor.selected[0].position.y = (Number(document.getElementsByClassName("UIElement")[1].children[2].children[5].children[1].value) - editor.selectionGroup.position.y + 1 || editor.selected[0].position.y + 1) - 1;
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[5].children[1].value = editor.selected.length && editor.selected[0].getWorldPosition(new THREE.Vector3).y;
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[5].children[2]) {
            editor.selected[0].position.z = (Number(document.getElementsByClassName("UIElement")[1].children[2].children[5].children[2].value) - editor.selectionGroup.position.z + 1 || editor.selected[0].position.z + 1) - 1;
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[5].children[2].value = editor.selected.length && editor.selected[0].getWorldPosition(new THREE.Vector3).z;
          }
          
          //rotation
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[7].children[0]) {
            editor.selected[0].rotation.x = (THREE.MathUtils.degToRad(Number(document.getElementsByClassName("UIElement")[1].children[2].children[7].children[0].value)) - editor.selectionGroup.rotation.x + 1 || editor.selected[0].rotation.x + 1) - 1;
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[7].children[0].value = editor.selected.length && THREE.MathUtils.radToDeg(new THREE.Euler().setFromQuaternion(editor.selected[0].getWorldQuaternion(new THREE.Quaternion)).x);
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[7].children[1]) {
            editor.selected[0].rotation.y = (THREE.MathUtils.degToRad(Number(document.getElementsByClassName("UIElement")[1].children[2].children[7].children[1].value)) - editor.selectionGroup.rotation.y + 1 || editor.selected[0].rotation.y + 1) - 1;
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[7].children[1].value = editor.selected.length && THREE.MathUtils.radToDeg(new THREE.Euler().setFromQuaternion(editor.selected[0].getWorldQuaternion(new THREE.Quaternion)).y);
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[7].children[2]) {
            editor.selected[0].rotation.z = (THREE.MathUtils.degToRad(Number(document.getElementsByClassName("UIElement")[1].children[2].children[7].children[2].value)) - editor.selectionGroup.rotation.z + 1 || editor.selected[0].rotation.z + 1) - 1;
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[7].children[2].value = editor.selected.length && THREE.MathUtils.radToDeg(new THREE.Euler().setFromQuaternion(editor.selected[0].getWorldQuaternion(new THREE.Quaternion)).z);
          }
          
          //scale
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[9].children[0]) {
            editor.selected[0].scale.x = (Number(document.getElementsByClassName("UIElement")[1].children[2].children[9].children[0].value) * editor.selectionGroup.scale.x || editor.selected[0].scale.x);
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[9].children[0].value = editor.selected.length && editor.selected[0].getWorldScale(new THREE.Vector3).x;
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[9].children[1]) {
            editor.selected[0].scale.y = (Number(document.getElementsByClassName("UIElement")[1].children[2].children[9].children[1].value) * editor.selectionGroup.scale.y || editor.selected[0].scale.y);
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[9].children[1].value = editor.selected.length && editor.selected[0].getWorldScale(new THREE.Vector3).y;
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[1].children[2].children[9].children[2]) {
            editor.selected[0].scale.z = (Number(document.getElementsByClassName("UIElement")[1].children[2].children[9].children[2].value) * editor.selectionGroup.scale.z || editor.selected[0].scale.z);
          } else {
            document.getElementsByClassName("UIElement")[1].children[2].children[9].children[2].value = editor.selected.length && editor.selected[0].getWorldScale(new THREE.Vector3).z;
          }
          
          //collidable attribute
          document.getElementsByClassName("UIElement")[1].children[2].children[19].onchange = function () {
            editor.undoableAttributechange(editor.selected[0], "COLLIDABLE", this.checked);
          }
          document.getElementsByClassName("UIElement")[1].children[2].children[19].checked = editor.selected[0].COLLIDABLE;
          
          //material attribute
          document.getElementsByClassName("UIElement")[1].children[2].children[21].onchange = function () {
            editor.undoableAttributechange(editor.selected[0], "MATERIAL", this.value);
          }
          document.getElementsByClassName("UIElement")[1].children[2].children[21].value = editor.selected[0].MATERIAL;
          
          //invisible attribute
          document.getElementsByClassName("UIElement")[1].children[2].children[23].onchange = function () {
            editor.undoableAttributechange(editor.selected[0], "INVISIBLE", this.checked);
          }
          document.getElementsByClassName("UIElement")[1].children[2].children[23].checked = editor.selected[0].INVISIBLE;
         
          //unhittable attribute
          document.getElementsByClassName("UIElement")[1].children[2].children[25].onchange = function () {
            editor.undoableAttributechange(editor.selected[0], "unHittable", this.checked);
          }
          document.getElementsByClassName("UIElement")[1].children[2].children[25].checked = editor.selected[0].unHittable;
          
          //color attribute
          document.getElementsByClassName("UIElement")[1].children[2].children[27].oninput = function () {
            editor.undoableAttributechange(editor.selected[0], "COLOR", this.value);
          }
          document.getElementsByClassName("UIElement")[1].children[2].children[27].value = editor.selected[0].COLOR;
          
          //stretch attribute
          document.getElementsByClassName("UIElement")[1].children[2].children[15].children[0].oninput = function () {
            editor.undoableAttributechange(editor.selected[0], "TEXTURE_STRETCH[0]", this.value);
          }
          document.getElementsByClassName("UIElement")[1].children[2].children[15].children[0].value = editor.selected[0].TEXTURE_STRETCH[0];
          
          document.getElementsByClassName("UIElement")[1].children[2].children[15].children[1].oninput = function () {
            editor.undoableAttributechange(editor.selected[0], "TEXTURE_STRETCH[1]", this.value);
          }
          document.getElementsByClassName("UIElement")[1].children[2].children[15].children[1].value = editor.selected[0].TEXTURE_STRETCH[1];
        }
        if(editor.MODE == "bound") {
          //visualization
          editor.boundObject.scale.set(editor.MAP_DATA.map.boundaries[0]-editor.MAP_DATA.map.boundaries[1], editor.MAP_DATA.map.boundaries[2]-editor.MAP_DATA.map.boundaries[3], editor.MAP_DATA.map.boundaries[4]-editor.MAP_DATA.map.boundaries[5]);
          editor.boundObject.position.set((editor.MAP_DATA.map.boundaries[0]+editor.MAP_DATA.map.boundaries[1])/2, (editor.MAP_DATA.map.boundaries[2]+editor.MAP_DATA.map.boundaries[3])/2, (editor.MAP_DATA.map.boundaries[4]+editor.MAP_DATA.map.boundaries[5])/2);
          //max values
          if (document.activeElement == document.getElementsByClassName("UIElement")[0].children[2].children[0].children[0]) {
            var value = Number(document.getElementsByClassName("UIElement")[0].children[2].children[0].children[0].value);
            value != editor.MAP_DATA.map.boundaries[0] && editor.undoableAttributechange(editor.MAP_DATA.map, "boundaries[0]", value);
          } else {
            document.getElementsByClassName("UIElement")[0].children[2].children[0].children[0].value = editor.MAP_DATA.map.boundaries[0];
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[0].children[2].children[0].children[1]) {
            var value = Number(document.getElementsByClassName("UIElement")[0].children[2].children[0].children[1].value);
            value != editor.MAP_DATA.map.boundaries[2] && editor.undoableAttributechange(editor.MAP_DATA.map, "boundaries[2]", value);
          } else {
            document.getElementsByClassName("UIElement")[0].children[2].children[0].children[1].value = editor.MAP_DATA.map.boundaries[2];
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[0].children[2].children[0].children[2]) {
            var value = Number(document.getElementsByClassName("UIElement")[0].children[2].children[0].children[2].value);
            value != editor.MAP_DATA.map.boundaries[4] && editor.undoableAttributechange(editor.MAP_DATA.map, "boundaries[4]", value);
          } else {
            document.getElementsByClassName("UIElement")[0].children[2].children[0].children[2].value = editor.MAP_DATA.map.boundaries[4];
          }
          //min values
          if (document.activeElement == document.getElementsByClassName("UIElement")[0].children[2].children[2].children[0]) {
            var value = Number(document.getElementsByClassName("UIElement")[0].children[2].children[2].children[0].value);
            value != editor.MAP_DATA.map.boundaries[1] && editor.undoableAttributechange(editor.MAP_DATA.map, "boundaries[1]", value);
          } else {
            document.getElementsByClassName("UIElement")[0].children[2].children[2].children[0].value = editor.MAP_DATA.map.boundaries[1];
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[0].children[2].children[2].children[1]) {
            var value = Number(document.getElementsByClassName("UIElement")[0].children[2].children[2].children[1].value);
            value != editor.MAP_DATA.map.boundaries[3] && editor.undoableAttributechange(editor.MAP_DATA.map, "boundaries[3]", value);
          } else {
            document.getElementsByClassName("UIElement")[0].children[2].children[2].children[1].value = editor.MAP_DATA.map.boundaries[3];
          }
          if (document.activeElement == document.getElementsByClassName("UIElement")[0].children[2].children[2].children[2]) {
            var value = Number(document.getElementsByClassName("UIElement")[0].children[2].children[2].children[2].value);
            value != editor.MAP_DATA.map.boundaries[5] && editor.undoableAttributechange(editor.MAP_DATA.map, "boundaries[5]", value);
          } else {
            document.getElementsByClassName("UIElement")[0].children[2].children[2].children[2].value = editor.MAP_DATA.map.boundaries[5];
          }
        }
        if(editor.MODE == "skybox") {
          //-X attribute
          document.getElementById("texture_list_1").onchange = function () {
            editor.undoableAttributechange(editor.MAP_DATA.map, "skybox[1]", this.value, true);
            try {
              loadSky(...editor.MAP_DATA.map.skybox);
            } catch (e) {}
          }
          //+X attribute
          document.getElementById("texture_list_2").onchange = function () {
            editor.undoableAttributechange(editor.MAP_DATA.map, "skybox[0]", this.value, true);
            try {
              loadSky(...editor.MAP_DATA.map.skybox);
            } catch (e) {}
          }
          //-Y attribute
          document.getElementById("texture_list_3").onchange = function () {
            editor.undoableAttributechange(editor.MAP_DATA.map, "skybox[3]", this.value, true);
            try {
              loadSky(...editor.MAP_DATA.map.skybox);
            } catch (e) {}
          }
          //+Y attribute
          document.getElementById("texture_list_4").onchange = function () {
            editor.undoableAttributechange(editor.MAP_DATA.map, "skybox[2]", this.value, true);
            try {
              loadSky(...editor.MAP_DATA.map.skybox);
            } catch (e) {}
          }
          //-Z attribute
          document.getElementById("texture_list_5").onchange = function () {
            editor.undoableAttributechange(editor.MAP_DATA.map, "skybox[5]", this.value, true);
            try {
              loadSky(...editor.MAP_DATA.map.skybox);
            } catch (e) {}
          }
          //+Z attribute
          document.getElementById("texture_list_6").onchange = function () {
            editor.undoableAttributechange(editor.MAP_DATA.map, "skybox[4]", this.value, true);
            try {
              loadSky(...editor.MAP_DATA.map.skybox);
            } catch (e) {}
          }
        }
        if(editor.MODE == "play") {
          if(document.getElementById("testIframe").contentWindow.ws && document.getElementById("testIframe").contentWindow.ws.readyState == 3) {
            editor.setMode("play");
          }
        }
      }
      
      editor.getUpload = function (callback, type="*") {
        document.getElementById("fileUploader").accept = "."+type;
        document.getElementById("fileUploader").click();
        document.getElementById("fileUploader").onclick = function () {
          this.value = null;
        };
        document.getElementById("fileUploader").oninput = function() {
          callback(document.getElementById("fileUploader").files);
        }
        return true;
      }
      
      editor.processImage = function(fileList) {
        return editor.createTexture(URL.createObjectURL(fileList[0]), fileList[0].name.split(".")[0]);
      }
      
      editor.getFileFromGame = function(type, path, callback, name="image") {
        var window_ = new editor.Window(600, 400, 200, 200, 'Import '+name+' from game');
        window_.windowContents.innerHTML = "<iframe id='upload_iframe' src="+path+">";
        var e=document.getElementById("upload_iframe");
        e.width="100%";
        e.height="100%";
        e.style.border="none";
        e.contentWindow.onload = function () {
          e.contentDocument.body.children[0].outerHTML = "";
        }
        function wait() {
          if(e.contentWindow.location.href.split("/")[e.contentWindow.location.href.split("/").length-1].split(".")[1] == type) {
            callback(e.contentWindow.location.href);
            window_.close();
          }
          window_.window.outerHTML && setTimeout(wait, 1);
        }
        wait();
      }
      
      editor.mainLoop = function () {
        //render world
        renderer.render(scene, camera);
        
        //CALCULATE DELTA
        editor.delta = (Date.now() - editor.lastUpdate) / 1000;
        editor.lastUpdate = Date.now();
        
        //update tools
        if(editor.currentTool) {
          editor.currentTool.axisList.forEach(function (object) {
            object.visible = !editor.hideTool;
            if(object.darkened) {
              object.darkened = false;
              object.material.color = object.default_color;
            }
          });
          raycaster.setFromCamera(mouse, camera);
          var result = raycaster.intersectObjects(editor.currentTool.axisList);
          if(result[0]) {
            if(result[0].object.axis) {
              if(!result[0].object.darkened) {
                result[0].object.darkened = true;
                result[0].object.material.color = result[0].object.dark_color;
              }
            }
          }
          editor.currentTool.origin.position.copy(editor.selectionGroup.position);
          editor.currentTool.origin.visible = !editor.hideTool;
          editor.currentTool.axisList.forEach(function (object) {
            object.position.copy(editor.selectionGroup.position);
            object.renderOrder = 100;
          });
          editor.currentTool.planes.forEach(function (object) {
            object.position.copy(editor.selectionGroup.position);
          });
        }
        editor.tools.list.forEach(function (tool) {
          tool.axisList.forEach(function (object) {
            object.scale.set(object.position.distanceTo(camera.position)/10, object.position.distanceTo(camera.position)/10, object.position.distanceTo(camera.position)/10);
          });
        });
        
        //update UI
        editor.updateUI();
        
        //update editor
        FirstPersonControls.update(editor.delta);
        if(renderer.domElement.parentElement) {
          camera.aspect = renderer.domElement.parentElement.clientWidth / renderer.domElement.parentElement.clientHeight;
          renderer.setSize(renderer.domElement.parentElement.clientWidth, renderer.domElement.parentElement.clientHeight);
        }
        editor.objects.forEach(function (object) {
          object.selection.matrix.copy(object.matrixWorld);
          object.material.needsUpdate = true;
          object.material.alphaTest = !object.INVISIBLE && (editor.object_types[object.type] && editor.object_types[object.type].materialalphaTest || 0.95);
          object.material.transparent = object.INVISIBLE;
          object.material.opacity = editor.options.renderInvisible && (object.INVISIBLE && 0.5 || 1) || (object.INVISIBLE && 0.0001 || 1);
          object.material.transparent = object.INVISIBLE;
          editor.object_types[object.type] && editor.object_types[object.type].textured && object.material.color.set(object.COLOR);
          if(object.material.map) {
            object.material.map.needsUpdate = true;
            object.material.map.repeat.x = object.TEXTURE_STRETCH[0];
            object.material.map.repeat.y = object.TEXTURE_STRETCH[1];
            object.material.map.wrapS=object.material.map.wrapT=THREE.RepeatWrapping;
            object.material.map.needsUpdate = true;
          }
        });
        camera.updateProjectionMatrix();
        camera.updateMatrixWorld();
        requestAnimationFrame(editor.mainLoop);
      }
      
      //tool class
      editor.tools = {
        classes: {},
        list: []
      }
      editor.currentTool = null;
      editor.toolActive = false;
      editor.tools.classes.Tool = class {
        constructor() {
          this.type = "Tool";
          this.origin = new THREE.Sprite(new THREE.SpriteMaterial({map: textureLoader.load("assets/textures/editor/tool_select.png"), sizeAttenuation: false, opacity: 14, depthTest: false}));
          this.origin.scale.set(0.025, 0.025, 0.025);
          scene.add(this.origin);
          this.axes = 3;
          this.axisList = [];
          this.planes = [];
          this.planeConfiguration = [[0, 0, 0], [0, 0, 0], [0, -90, 0]];
          editor.tools.list.push(this);
        }
        initialize() {
          var _this = this;
          for (let i = 0; i < this.axes; i++) {
            var plane = new THREE.Mesh(new THREE.BoxGeometry(100000, 100000, 0.1));
            plane.visible = false;
            this.planes.push(plane);
            scene.add(plane);
            plane.rotation.set(THREE.MathUtils.degToRad(this.planeConfiguration[i][0]), THREE.MathUtils.degToRad(this.planeConfiguration[i][1]), THREE.MathUtils.degToRad(this.planeConfiguration[i][2]));
            loader.load("assets/models/editor/tools/"+this.type+"/"+i+".glb", function (gltf) {
              _this.axisList.push(gltf.scene.children[0]);
              gltf.scene.children[0].material.depthTest = 0;
              gltf.scene.children[0].material.depthWrite = 0;
              gltf.scene.children[0].axis = i+1;
              gltf.scene.children[0].default_color = gltf.scene.children[0].material.color.clone();
              gltf.scene.children[0].dark_color = gltf.scene.children[0].material.color.clone().lerp(new THREE.Color("#000"), .2);
              gltf.scene.children[0].visible = false;
              _this.origin.visible = false;
              scene.add(gltf.scene.children[0]);
            });
          }
        }
        select() {
          editor.currentTool = this;
          this.origin.visible = true;
          for (var i = 0; i < this.axes; i++) {
            this.axisList[i].visible = true;
          }
        }
        deselect() {
          editor.currentTool = (editor.currentTool != this && editor.currentTool) || null;
          this.origin.visible = false;
          for (var i = 0; i < this.axes; i++) {
            this.axisList[i].visible = false;
          }
        }
        raycastPlane(axis) {
          raycaster.setFromCamera(mouse, camera);
          var result = raycaster.intersectObject(this.planes[axis]);
          return result[0];
        }
        onmousedown(axis) {
          
        }
        onmousemove(axis, event) {
          
        }
      }
      
      editor.tools.classes.MoveTool = class extends editor.tools.classes.Tool {
        constructor() {
          super();
          this.type = "MoveTool";
        }
        onmousedown(axis) {
          switch (axis) {
            case 0:
              this.offset = this.raycastPlane(axis).point.x-editor.selectionGroup.position.x;
              break;
            case 1:
              this.offset = this.raycastPlane(axis).point.y-editor.selectionGroup.position.y;
              break;
            case 2:
              this.offset = this.raycastPlane(axis).point.z-editor.selectionGroup.position.z;
              break;
          }
        }
        onmousemove(axis, event) {
          switch (axis) {
            case 0:
              editor.selectionGroup.position.x = this.raycastPlane(axis).point.x-this.offset;
              break;
            case 1:
              editor.selectionGroup.position.y = this.raycastPlane(axis).point.y-this.offset;
              break;
            case 2:
              editor.selectionGroup.position.z = this.raycastPlane(axis).point.z-this.offset;
              break;
          }
        }
      }
      
      editor.tools.classes.RotateTool = class extends editor.tools.classes.Tool {
        constructor() {
          super();
          this.type = "RotateTool";
          this.planeConfiguration = [[0, 90, 0], [90, 0, 0], [0, 0, 0]];
        }
        onmousedown(axis) {
          switch (axis) {
            case 0:
              this.offset = editor.selectionGroup.rotation.x;
              break;
            case 1:
              this.offset = editor.selectionGroup.rotation.y;
              break;
            case 2:
              this.offset = editor.selectionGroup.rotation.z;
              break;
          }
        }
        onmousemove(axis, event) {
          switch (axis) {
            case 0:
              editor.selectionGroup.rotation.x = Math.atan2(editor.selectionGroup.position.z-this.raycastPlane(axis).point.z, editor.selectionGroup.position.y-this.raycastPlane(axis).point.y)-this.offset;
              break;
            case 1:
              editor.selectionGroup.rotation.y = Math.atan2(editor.selectionGroup.position.x-this.raycastPlane(axis).point.x, editor.selectionGroup.position.z-this.raycastPlane(axis).point.z)-this.offset;
              break;
            case 2:
              editor.selectionGroup.rotation.z = -Math.atan2(editor.selectionGroup.position.x-this.raycastPlane(axis).point.x, editor.selectionGroup.position.y-this.raycastPlane(axis).point.y)-this.offset;
              break;
          }
        }
      }
      
      editor.tools.classes.ScaleTool = class extends editor.tools.classes.Tool {
        constructor() {
          super();
          this.type = "ScaleTool";
        }
        onmousedown(axis) {
          switch (axis) {
            case 0:
              this.offset = this.raycastPlane(axis).point.x-editor.selectionGroup.position.x;
              break;
            case 1:
              this.offset = this.raycastPlane(axis).point.y-editor.selectionGroup.position.y;
              break;
            case 2:
              this.offset = this.raycastPlane(axis).point.z-editor.selectionGroup.position.z;
              break;
          }
        }
        onmousemove(axis, event) {
          switch (axis) {
            case 0:
              var rotated = false;
              editor.selected.forEach(function (object) {
                if(Math.round(THREE.MathUtils.radToDeg(object.rotation.y)*1000)/1000 % 90 != 0 || Math.round(THREE.MathUtils.radToDeg(object.rotation.z)*1000)/1000 % 90 != 0) {
                  rotated = true;
                }
              });
              editor.selectionGroup.scale.x = this.raycastPlane(axis).point.x/this.offset;
              if(rotated) {
                editor.selectionGroup.scale.y = this.raycastPlane(axis).point.x/this.offset;
                editor.selectionGroup.scale.z = this.raycastPlane(axis).point.x/this.offset;
              }
              break;
            case 1:
              var rotated = false;
              editor.selected.forEach(function (object) {
                if(Math.round(THREE.MathUtils.radToDeg(object.rotation.x)*1000)/1000 % 90 != 0 || Math.round(THREE.MathUtils.radToDeg(object.rotation.z)*1000)/1000 % 90 != 0) {
                  rotated = true;
                }
              });
              editor.selectionGroup.scale.y = this.raycastPlane(axis).point.y/this.offset;
              if(rotated) {
                editor.selectionGroup.scale.x = this.raycastPlane(axis).point.y/this.offset;
                editor.selectionGroup.scale.z = this.raycastPlane(axis).point.y/this.offset;
              }
              break;
            case 2:
              var rotated = false;
              editor.selected.forEach(function (object) {
                if(Math.round(THREE.MathUtils.radToDeg(object.rotation.x)*1000)/1000 % 90 != 0 || Math.round(THREE.MathUtils.radToDeg(object.rotation.y)*1000)/1000 % 90 != 0) {
                  rotated = true;
                }
              });
              editor.selectionGroup.scale.z = this.raycastPlane(axis).point.z/this.offset;
              if(rotated) {
                editor.selectionGroup.scale.x = this.raycastPlane(axis).point.z/this.offset;
                editor.selectionGroup.scale.y = this.raycastPlane(axis).point.z/this.offset;
              }
              break;
          }
        }
      }
      
      //window class
      editor.windows = [];
      editor.Window = class {
        constructor(width=100, height=100, x=0, y=0, title="window") {
          this.window = document.createElement("window");
          this.windowHeader = document.createElement("windowHeader");
          this.windowContents = document.createElement("div");
          document.body.appendChild(this.window);
          this.window.appendChild(this.windowHeader);
          this.window.appendChild(this.windowContents);
          editor.windows.push(this);
          
          this.window.style.width = width;
          this.window.style.height = height;
          this.window.style.left = x;
          this.window.style.top = y;
          this.window.class = this;
          
          this.windowHeader.innerHTML = title+"<button style='right: 0; position: absolute; height: 30px; width: 30px; border: solid #4f4f4f 1px;' onclick=this.parentElement.parentElement.class.close()>x</button>";
          
          //https://www.w3schools.com/howto/howto_js_draggable.asp
          var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
          this.windowHeader.onmousedown = dragMouseDown;
          var this_ = this;

          function dragMouseDown(e) {
            e = e || window.event;
            e.preventDefault();
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
          }

          function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            // set the element's new position:
            this_.window.style.top = (this_.window.offsetTop - pos2) + "px";
            this_.window.style.left = (this_.window.offsetLeft - pos1) + "px";
          }

          function closeDragElement() {
            // stop moving when mouse button is released:
            document.onmouseup = null;
            document.onmousemove = null;
          }
        }
        close() {
          this.window.outerHTML = "";
          editor.windows.splice(editor.windows.indexOf(this), 1);
        }
      }
      
      //history
      editor.history.undo = [];
      editor.history.redo = [];
      editor.history.commands = [];
      editor.Command = class {
        constructor(undo, redo) {
          this.undoFunc = undo || console.log;
          this.redoFunc = redo || console.log;
          editor.history.commands.push(this);
          editor.history.undo.push(this);
          this.redoFunc();
          editor.history.redo.concat().forEach(function (item) {
            item.remove();
          });
        }
        undo() {
          editor.history.undo.splice(editor.history.undo.indexOf(this), 1);
          editor.history.redo.push(this);
          this.undoFunc();
        }
        redo() {
          editor.history.redo.splice(editor.history.redo.indexOf(this), 1);
          editor.history.undo.push(this);
          this.redoFunc();
        }
        remove() {
          editor.history.commands.splice(editor.history.commands.indexOf(this), 1);
          editor.history.undo.indexOf(this) != -1 && editor.history.undo.splice(editor.history.undo.indexOf(this), 1);
          editor.history.redo.indexOf(this) != -1 && editor.history.redo.splice(editor.history.redo.indexOf(this), 1);
        }
      }
      
      //saving and loading
      editor.SAVE = function(mode) {
        editor.MAP_DATA.map.objects = [];
        editor.deselect(editor.selected.concat());
        (typeof mode == "object" && mode || editor.objects).forEach(function(object) {
          !(editor.object_types[object.type] && editor.object_types[object.type].unsavable) && editor.MAP_DATA.map.objects.push({position: {x: object.position.x, y: object.position.y, z: object.position.z}, rotation:{x: THREE.MathUtils.radToDeg(object.rotation.x), y: THREE.MathUtils.radToDeg(object.rotation.y), z: THREE.MathUtils.radToDeg(object.rotation.z)}, scale: {x: object.scale.x, y: object.scale.y, z: object.scale.z}, collidable: object.COLLIDABLE, material: object.MATERIAL, texture: object.TEXTURE != "<none>" && object.TEXTURE || "", invisible: object.INVISIBLE, unHittable: object.unHittable, color: object.COLOR, texture_stretch: object.TEXTURE_STRETCH.concat(), name: object.name, type: object.type});
        });
        switch (mode) {
          case 1:
            //save map data to localStorage
            localStorage["MAP_FILE_"+editor.currentFileName] = JSON.stringify(editor.MAP_DATA, function (k,v){if(v==-Infinity){return "-Infinity"};if(v==Infinity){return "Infinity"};return v});
            break;
          case 2:
            if(!Object.values(editor.MAP_DATA.assets)[0]) {
              //no custom textures imported, best case scenario, download only map file
              document.getElementById("fileDownloader").href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(editor.MAP_DATA.map, function (k,v){if(v==-Infinity){return "-Infinity"};if(v==Infinity){return "Infinity"};return v}));
              document.getElementById("fileDownloader").download = (editor.currentFileName||"map")+".MAP";
              document.getElementById("fileDownloader").click()
            } else {
              //custom textures imported, download a zip file with all imported textures and map file
              var JSZip_ = new JSZip();
              JSZip_.file("map.MAP", JSON.stringify(editor.MAP_DATA.map, function (k,v){if(v==-Infinity){return "-Infinity"};if(v==Infinity){return "Infinity"};return v}));
              Object.values(editor.MAP_DATA.assets).forEach(function (contents, index) {
                JSZip_.file(Object.keys(editor.MAP_DATA.assets)[index]+".png", editor.srcToFile(contents, "", "image/png"));
              });
              JSZip_.generateAsync({type: 'blob'}).then(function (content) {
                document.getElementById("fileDownloader").href = URL.createObjectURL(content);
                document.getElementById("fileDownloader").download = (editor.currentFileName||"map")+".zip";
                document.getElementById("fileDownloader").click();
              });
            }
            break;
          case 3:
            //compress map's imported textures into map so that it can be injected into game for play testing
            editor.MAP_DATA.map.objects.forEach(function (e) {
              if(editor.MAP_DATA.assets[e.texture]) {
                e.texture = editor.MAP_DATA.assets[e.texture];
              }
            });
            break;
        }
        return editor.MAP_DATA;
      }
      editor.LOAD = async function(contents, mode) {
        editor.TEXTURES.forEach(function (texture) {
          if(texture.fake || mode == 5) return;
          delete editor.MAP_DATA.assets[texture.name];
          editor.TEXTURES.splice(editor.TEXTURES.indexOf(texture), 1);
        });
        var data = editor.MAP_DATA.map;
        switch (mode) {
          case 1:
            //individual map file
            var a = new FileReader();
            a.readAsText(contents);
            a.onload=function(event){
              data = JSON.parse(event.target.result);
              continueLoad();
            }
            break;
          case 2:
            //url
            editor.get_json(contents, function (a, b) {
              data = b;
              continueLoad();
            });
            break;
          case 3:
            //zip file
            var JSZip_ = new JSZip()
            var files = await JSZip.loadAsync(contents);
            files.forEach(async function (name, file) {
              if(name.split(".")[1] == "MAP") {
                var data_ = await file.async("text");
                data = JSON.parse(data_);
              } else {
                var blob = await file.async("blob");
                var a = new FileReader();
                a.readAsDataURL(blob);
                a.onload = function (event) {
                  var data_url = a.result;
                  editor.createTexture(data_url, name.split(".")[0]);
                  editor.MAP_DATA.assets[name.split(".")[0]]=data_url;
                }
              }
              setTimeout(continueLoad, 500);
            });
            break;
          case 4:
            //localStorage
            editor.MAP_DATA = JSON.parse(localStorage["MAP_FILE_"+contents]);
            data = editor.MAP_DATA.map;
            Object.keys(editor.MAP_DATA.assets).forEach(function (texture) {
              editor.createTexture(editor.MAP_DATA.assets[texture], texture);
            });
            break;
          case 5:
            //paste
            editor.MAP_DATA.map.objects = contents;
            break;
        }
        function continueLoad() {
          if(mode != 5) {
            editor.deleteObject(editor.objects);
            editor.MAP_DATA.map.skybox = data.skybox;
            editor.MAP_DATA.map.boundaries = data.boundaries[0] && data.boundaries || [Infinity, -Infinity, Infinity, -Infinity, Infinity, -Infinity];
            editor.MAP_DATA.map.objects = data.objects;
            editor.history.commands.concat().forEach(function(command) {
                command.remove()
            });
            resetSky();
            try {
              editor.options.renderSky && loadSky(...data.skybox);
            } catch (e) {}
          }
          //loop through all map objects and skybox
          editor.MAP_DATA.map.objects.forEach(function(object) {
            var obj = editor.createObject(object.position, object.type);
            obj.rotation.set(THREE.MathUtils.degToRad(object.rotation.x), THREE.MathUtils.degToRad(object.rotation.y), THREE.MathUtils.degToRad(object.rotation.z));
            obj.scale.set(object.scale.x, object.scale.y, object.scale.z);
            obj.COLLIDABLE = object.collidable;
            obj.MATERIAL = object.material;
            obj.TEXTURE = object.texture;
            obj.INVISIBLE = object.invisible;
            obj.unHittable = object.unHittable;
            obj.COLOR = object.color || "#ffffff";
            obj.TEXTURE_STRETCH = object.texture_stretch || [1,1];
            obj.name = object.name || "object";
            
            object.texture && !editor.MAP_DATA.assets[object.texture] && editor.textureChecks(object, finish);
            editor.MAP_DATA.assets[object.texture] && finish();
            function finish(path) {
              editor.createTexture(path+object.texture+".png",object.texture);
              obj.material.map = editor.TEXTURES.find(function(a) {return a.name == obj.TEXTURE}) || obj.material.map;
            }
          });
        }
        continueLoad();
      }
      
      //UI functions
      editor.triggerSave = function() {
        if(!editor.currentFileName) {
          var save = new editor.Window(250,130,550,250, 'Save current map');
          save.windowContents.innerHTML = "<br><br><br>Map name: <input placeholder='<name>' id='fileName' style='float: right'></input><br><br><div style='text-align: center; '><button style='height: 32' onclick='editor.currentFileName=document.getElementById(`fileName`).value; editor.triggerSave(); this.parentElement.children[1].click();'><h4 style='margin-top: 8px'>Save</h4></button><button style='height: 32; margin-left: 20px' onclick='this.parentElement.parentElement.parentElement.class.close();'><h4 style='margin-top: 8px'>Cancel</h4></button></div>";
          document.getElementById("fileName").focus();
          return;
        } else {
          editor.SAVE(1);
        }
      }
      editor.triggerOpen = function() {
        var open = new editor.Window(500,300,550,250, 'Open map');
        open.windowContents.innerHTML = "<br><br>map list:<hr>";
        open.window.style.overflowY = "scroll";
        Object.keys(localStorage).forEach(function (mapName, index) {
           open.windowContents.innerHTML += mapName.startsWith("MAP_FILE_") && "<button style='width: 93%; height: 10%; text-align: left;' onclick='editor.LOAD(`"+mapName.split("MAP_FILE_")[1]+"`, 4); this.parentElement.parentElement.children[0].children[0].click(); editor.currentFileName=`"+mapName.split("MAP_FILE_")[1]+"`'>"+mapName.split("MAP_FILE_")[1]+"<p style='float: right;'>Size: "+Math.round(localStorage[mapName].length/1000000*100)/100+"mb</p></button><button style='width: 7%; height: 10%; float: right;' onclick='editor.triggerDelete(this.previousSibling.innerHTML.split(`<p`)[0]);this.parentElement.parentElement.children[0].children[0].click();'><img src='assets/textures/editor/trash.png'></img></button>" || "";
        });
      }
      editor.triggerCopy = function() {
        var objects = editor.selected.concat();
        editor.deselect(objects);
        editor.hideTool = true;
        navigator.clipboard.writeText(JSON.stringify(editor.SAVE(objects).map.objects));
      }
      editor.triggerHelp = function() {
        var help = new editor.Window(550, 400, 505, 200, "Help");
        help.windowContents.innerHTML = "<br><h4>Pixel Arena Map Editor help</h4><b>Shortcuts</b><br>Ctrl a - select all<br>Ctrl s - save<br>Ctrl o - open<br>Ctrl n - new<br>Ctrl c - copy<br>Ctrl v - paste<br>Ctrl z - undo<br>Ctrl y - redo<br><br><b>Editors</b><br>Map editor - transform and edit map's obects<br>Bound editor - edit map's boundaries, if a player ends up outside of these boundaries, the anticheat will kick them<br>Skybox editor - configure the map's skybox<br>Play test - run the game with your map";
      }
      editor.triggerDelete = function(map, confirm) {
        if(confirm) {
          delete localStorage["MAP_FILE_"+map];
        } else {
          var confirm = new editor.Window(300, 150, 525, 220, "This action is permanent");
          confirm.windowContents.innerHTML = "<br><br><br>Are you sure you want to delete this map? This cannot be undone!<br><br><button style='margin-left: 25%; height: 32px;' onclick='editor.triggerDelete(`"+map+"`, true);this.nextSibling.click();'><h4 style='margin-top: 8px;'>Delete</h4></button><button style='margin-left: 5%; height: 32px;' onclick='this.parentElement.parentElement.children[0].children[0].click();'><h4 style='margin-top: 8px;'>Cancel</h4></button>";
        }
      }
      editor.triggerUndo = function() {
        editor.history.undo[editor.history.undo.length-1] && editor.history.undo[editor.history.undo.length-1].undo();
      }
      editor.triggerRedo = function() {
        editor.history.redo[editor.history.redo.length-1] && editor.history.redo[editor.history.redo.length-1].redo();
      }
      
      //useful functions
      editor.srcToFile = function (src, fileName, mimeType){
          return (fetch(src)
              .then(function(res){return res.arrayBuffer();})
              .then(function(buf){return new File([buf], fileName, {type:mimeType});})
          );
      }
      
      //events
      renderer.domElement.addEventListener("wheel", function (event) {
        camera.position.add(new THREE.Vector3(0, 0, event.deltaY/200).applyQuaternion(camera.quaternion));
      });
      renderer.domElement.addEventListener("mousedown", function (event) {
        if(event.button == 0) {
          //individual object selection and tools
          raycaster.setFromCamera(mouse, camera);
          var result = raycaster.intersectObjects(editor.currentTool && editor.objects.concat(editor.currentTool.axisList) || editor.objects);
          var target = false;
          result.forEach(function (raycastResult) {
            if(raycastResult.object.axis && target && !target.axis) {
              target = raycastResult.object;
            }
            if(!target) {
              target = raycastResult.object;
            }
          });
          if(target) {
            if (!target.axis) {     
              //hit an object in the game world
              if(!event.shiftKey) { 
                editor.undoableDeselect(editor.objects);
              }
              if(!editor.selected.includes(target)) {
                editor.undoableSelect([target]);
              } else {
                editor.undoableDeselect([target]);
              }
            } else {
              //hit a tool axis
              editor.currentTool.onmousedown(target.axis-1);
              editor.toolActive = target.axis;
              editor.currentTool.oldPosition = editor.selectionGroup.position.clone();
              editor.currentTool.oldRotation = editor.selectionGroup.rotation.clone();
              editor.currentTool.oldScale = editor.selectionGroup.scale.clone();
            }
          } else {
            if(!event.shiftKey) {
              editor.undoableDeselect(editor.objects);
            }
          } 
          //rectangular selection
          if(!editor.toolActive) {
            editor.setRectangularSelection(event.x, event.y);
            editor.rectangularSelectionActive = true;
          }
          //tool visibility
          editor.hideTool = !editor.selected.length;
        }
      });
      renderer.domElement.addEventListener("mousemove", function (event) {
        if(event.button == 0 && editor.rectangularSelectionActive) editor.resizeRectangularSelection(event.x, event.y);
        mouse.set(((event.clientX - renderer.domElement.getBoundingClientRect().x) / renderer.domElement.clientWidth)*2 - 1, -((event.clientY - renderer.domElement.getBoundingClientRect().y) / renderer.domElement.clientHeight)*2 + 1);
        if(editor.toolActive) editor.currentTool.onmousemove(editor.toolActive-1, event, mouse)
      });
      renderer.domElement.addEventListener("mouseup", function (event) {
        if(event.button == 0) {
          editor.processRectangularSelection(event.shiftKey);
          editor.rectangularSelectionActive = false;
          if(editor.toolActive) {
            //undo-redo command
            editor.currentTool.offsetPosition = editor.selectionGroup.position.clone().sub(editor.currentTool.oldPosition);
            editor.currentTool.offsetRotation = new THREE.Euler(editor.selectionGroup.rotation.x-editor.currentTool.oldRotation.x, editor.selectionGroup.rotation.y-editor.currentTool.oldRotation.y, editor.selectionGroup.rotation.z-editor.currentTool.oldRotation.z);
            editor.currentTool.offsetScale = editor.selectionGroup.scale.clone();
            new editor.Command(function(){editor.selectionGroup.position.sub(this.offsetPosition);editor.selectionGroup.rotation.x-=this.offsetRotation.x;editor.selectionGroup.rotation.y-=this.offsetRotation.y;editor.selectionGroup.rotation.z-=this.offsetRotation.z;editor.selectionGroup.scale.divide(this.offsetScale);setTimeout(editor.selectionApplyTransforms,20);}, function(){if(this.offsetPosition){editor.selectionGroup.position.add(this.offsetPosition);editor.selectionGroup.rotation.x+=this.offsetRotation.x;editor.selectionGroup.rotation.y+=this.offsetRotation.y;editor.selectionGroup.rotation.z+=this.offsetRotation.z;editor.selectionGroup.scale.multiply(this.offsetScale);setTimeout(editor.selectionApplyTransforms,20);};this.offsetPosition = this.offsetPosition || editor.currentTool.offsetPosition;this.offsetRotation = this.offsetRotation || editor.currentTool.offsetRotation;this.offsetScale = this.offsetScale || editor.currentTool.offsetScale;});
            //apply
            editor.selectionApplyTransforms();
          }
          editor.toolActive = false;
        }
      });
      document.addEventListener("click", function (event) {
        //context menu
        for(var i = 0; i < document.getElementsByClassName("contextmenu").length; i++) {
          document.getElementsByClassName("contextmenu")[i].style.display = "none";
        }
        //dropdowns
        if(event.target.className == "dropdown" || event.target.parentElement.className == "dropdown") {
          document.getElementById("dropdown."+(event.target.name || event.target.parentElement.name)).style.display = "block";
        }
      });
      document.addEventListener("contextmenu", function (event) {
        //context menu
        event.preventDefault();
        if (!event.target.contextMenu && !event.target.parentElement.contextMenu) return;
        document.getElementsByClassName("contextmenu")[0].target = event.target;
        document.getElementsByClassName("contextmenu")[0].style.display = "block";
        document.getElementsByClassName("contextmenu")[0].style.left = event.pageX;
        document.getElementsByClassName("contextmenu")[0].style.top = event.pageY;
      });
      document.addEventListener("keydown", function (event) {
        //CTRL A
        if(event.ctrlKey && event.keyCode == 65) {
          editor.undoableSelect(editor.objects);
          event.preventDefault();
          //tool visibility
          editor.hideTool = !editor.selected.length;
        }
        //CTRL S
        if(event.ctrlKey && event.keyCode == 83) {
          editor.triggerSave();
          event.preventDefault();
        }
        //CTRL O
        if(event.ctrlKey && event.keyCode == 79) {
          editor.triggerOpen();
          event.preventDefault();
        }
        //CTRL N
        if(event.ctrlKey && event.keyCode == 78) {
          location.reload();
          event.preventDefault();
        }
        //CTRL C
        if(event.ctrlKey && event.keyCode == 67 && event.target.tagName != "INPUT") {
          editor.triggerCopy();
          event.preventDefault();
        }
        //CTRL Z
        if(event.ctrlKey && event.keyCode == 90) {
          editor.triggerUndo();
          event.preventDefault();
        }
        //CTRL Y
        if(event.ctrlKey && event.keyCode == 89) {
          editor.triggerRedo();
          event.preventDefault();
        }
        //delete
        if(event.keyCode == 46 && !document.activeElement.type) {
          editor.undoableDeleteObject(editor.selected);
          //tool visibility
          editor.hideTool = !editor.selected.length;
        }
        //f1
        if(event.keyCode == 112) {
          event.preventDefault();
          editor.triggerHelp();
        }
      });
      document.addEventListener("paste", function (event) {
        if(event.target.tagName != "INPUT") {
          event.preventDefault();
          try {
            //attempt to paste
            var data = event.clipboardData.getData("text");
            new editor.Command(function() {
              editor.deleteObject(this.objects);
              editor.hideTool = false;
            }, function() {
              var old_objects = editor.objects.concat();
              editor.LOAD(JSON.parse(data), 5);
              var this_ = this;
              setTimeout(function(){
                this_.objects = editor.objects.filter(n => !old_objects.includes(n));
                editor.select(this_.objects);
                editor.hideTool = false;
              }, 100);
            });
          } catch (e) {}
        }
      });
      
      //initalize
      editor.initialize = function () {
        //prepare all UI tabs
        for(var i = 0; i < document.getElementsByClassName("tab").length; i++) {
          document.getElementsByClassName("tab")[i].onclick = function(){editor.setMode(this.id.split('_')[1])};
        }
        
        //define modes
        editor.MODES.map = function (o) {
          editor.windows.forEach(function (win) {win.close()});
          o.innerHTML += "<div class='UIelement' style='position: absolute; left: 0; height: 60%; width: 16%; overflow-y: scroll'><div style='margin-left: 7%'>Objects</div><hr><div id=object_list></div></div><div class='UIelement' style='position: absolute; right: 0; height: 92%; width: 20%; overflow-y: scroll'><div style='margin-left: 7%'>Inspector</div><hr><div style='margin-left: 5%'><img src='assets/textures/editor/object.png' width=16> Name: <input placeholder='object'></input><hr style='margin-left: -5%'>Transform<br><br>Position <a style='margin-left: 13%'>X <input style='width:10%'></input> Y <input style='width:10%'></input> Z <input style='width:10%'></input></a><br>Rotation <a style='margin-left: 13%'>X <input style='width:10%'></input> Y <input style='width:10%'></input> Z <input style='width:10%'></input></a><br>Scale <a style='margin-left: 18.75%'>X <input style='width:10%'></input> Y <input style='width:10%'></input> Z <input style='width:10%'></input></a><hr>Texture<br><br>Texture <select id=texture_list style='margin-left: 10%'></select><br>Stretch <a style='margin-left:13%'>X <input style='width:10%'>Y <input style='width:10%'></a><hr>Attributes<br><br>Collidable <input type='checkbox' style='margin-left: 10%'><br>Material <select style='margin-left: 11%'><option value='concrete'>concrete</option><option value='wood'>wood</option></select><br>Invisible <input type='checkbox' style='margin-left: 12.5%'><br>Unhittable <input type='checkbox' style='margin-left: 7.75%'><br>Color <input type='color' style='margin-left: 19%'></div></div><div class='UIElement' style='position: absolute; left: 0; bottom: 0; height: 32.5%; width: 79.85%; overflow-y: scroll'><div id=texture_list_large></div><button style='width: 5%; position: absolute; right: 0' class='dropdown' name='texture'><h1>+</h1></button></div><div class='UIElement' style='position: absolute; top: 75px; left: 17%'><button onclick='for(var i = 0; i < editor.tools.list.length; i++){editor.tools.list[i].deselect()};editor.tools.list[0].select()'><img src='assets/textures/editor/move_tool.png' width=32 height=32 style=margin-left:-4px></button><br><button onclick='for(var i = 0; i < editor.tools.list.length; i++){editor.tools.list[i].deselect()};editor.tools.list[1].select()'><img src='assets/textures/editor/rotate_tool.png' width=32 height=32 style=margin-left:-4px></button><br><button onclick='for(var i = 0; i < editor.tools.list.length; i++){editor.tools.list[i].deselect()};editor.tools.list[2].select()'><img src='assets/textures/editor/scale_tool.png' width=32 height=32 style=margin-left:-4px></button></div>";
          o.appendChild(renderer.domElement);
        }
        editor.MODES.bound = function (o) {
          editor.windows.forEach(function (win) {win.close()});
          o.innerHTML += "<div class='UIelement' style='position: absolute; left: 0; height: 100%; width: 20%; overflow-y: scroll'><div style='margin-left: 7%'>Boundary editor</div><hr><div style='margin-left: 5%'>Max values <a style='margin-left: 3%'>X <input style='width:10%'> Y <input style='width:10%'> Z <input style='width:10%'></input></a><br>Min values <a style='margin-left: 5.5%'>X <input style='width:10%'> Y <input style='width:10%'> Z <input style='width:10%'></input></a><br><br>Enabled <input type='checkbox' id='bounds_enabled' onclick='if(editor.MAP_DATA.map.boundaries[0]!=Infinity){editor.MAP_DATA.map.boundaries=[Infinity, -Infinity, Infinity, -Infinity, Infinity, -Infinity]}else{editor.MAP_DATA.map.boundaries=[50, -50, 25, -25, 50, -50]}'></input></div></div>";
          document.getElementById("bounds_enabled").checked = isFinite(editor.MAP_DATA.map.boundaries[0]);
          editor.boundObject && editor.deleteObject(editor.boundObject) && delete(editor.boundObject);
          editor.boundObject = editor.createObject({x:0,y:0,z:0}, "bound_visualization");
          editor.boundObject.INVISIBLE = true;
          for(var i = 0; i < editor.tools.list.length; i++){editor.tools.list[i].deselect()};
          o.appendChild(renderer.domElement);
        }
        editor.MODES.skybox = function (o) {
          editor.windows.forEach(function (win) {win.close()});
          o.innerHTML += "<div class='UIelement' style='position: absolute; right: 0; height: 30%; width: 22%; overflow-y: scroll'><div style='margin-left: 7%'>Skybox editor</div><hr><div style='margin-left: 5%'>Negative X <input style='width:50%' id=texture_list_1 style='margin-left: 10%'></input><button style='margin-right: 1px' onclick='var this_ = this;editor.getFileFromGame(`png`, `assets/textures`, function(e){this_.previousSibling.value=e.split(`assets/textures/`)[1];this_.previousSibling.onchange.call(this_.previousSibling)}, `image`)'>browse</button><br>Positive X <input style='width:50%' id=texture_list_2 style='margin-left: 10%'></input><button style='margin-right: 1px' onclick='var this_ = this;editor.getFileFromGame(`png`, `assets/textures`, function(e){this_.previousSibling.value=e.split(`assets/textures/`)[1];this_.previousSibling.onchange.call(this_.previousSibling)}, `image`)'>browse</button><br>Negative Y <input style='width:50%' id=texture_list_3 style='margin-left: 10%'></input><button style='margin-right: 1px' onclick='var this_ = this;editor.getFileFromGame(`png`, `assets/textures`, function(e){this_.previousSibling.value=e.split(`assets/textures/`)[1];this_.previousSibling.onchange.call(this_.previousSibling)}, `image`)'>browse</button><br>Positive Y <input style='width:50%' id=texture_list_4 style='margin-left: 10%'></input><button style='margin-right: 1px' onclick='var this_ = this;editor.getFileFromGame(`png`, `assets/textures`, function(e){this_.previousSibling.value=e.split(`assets/textures/`)[1];this_.previousSibling.onchange.call(this_.previousSibling)}, `image`)'>browse</button><br>Negative Z <input style='width:50%' id=texture_list_5 style='margin-left: 10%'></input><button style='margin-right: 1px' onclick='var this_ = this;editor.getFileFromGame(`png`, `assets/textures`, function(e){this_.previousSibling.value=e.split(`assets/textures/`)[1];this_.previousSibling.onchange.call(this_.previousSibling)}, `image`)'>browse</button><br>Positive Z <input style='width:50%' id=texture_list_6 style='margin-left: 10%'></input><button style='margin-right: 1px' onclick='var this_ = this;editor.getFileFromGame(`png`, `assets/textures`, function(e){this_.previousSibling.value=e.split(`assets/textures/`)[1];this_.previousSibling.onchange.call(this_.previousSibling)}, `image`)'>browse</button></div></div>";
          document.getElementById("texture_list_1").value = editor.MAP_DATA.map.skybox[1] || "<none>";
          document.getElementById("texture_list_2").value = editor.MAP_DATA.map.skybox[0] || "<none>";
          document.getElementById("texture_list_3").value = editor.MAP_DATA.map.skybox[3] || "<none>";
          document.getElementById("texture_list_4").value = editor.MAP_DATA.map.skybox[2] || "<none>";
          document.getElementById("texture_list_5").value = editor.MAP_DATA.map.skybox[5] || "<none>";
          document.getElementById("texture_list_6").value = editor.MAP_DATA.map.skybox[4] || "<none>";
          o.appendChild(renderer.domElement);
          try {
            loadSky(...editor.MAP_DATA.map.skybox);
          } catch (e) {
            resetSky();
          }
        }
        editor.MODES.play = function (o) {
          editor.windows.forEach(function (win) {win.close()});
          o.innerHTML += "<iframe src='about:blank' style='width: 100%; height: 100%; border: none; overflow: hidden;' id='testIframe'></iframe>";
          setTimeout(function(){document.getElementById("testIframe").contentDocument.body.style.overflow = "hidden"; document.getElementById("testIframe").contentDocument.body.style.backgroundColor = "#686868"; document.getElementById("testIframe").contentDocument.body.innerHTML = "<div style='text-align: center;'><br><br><br><br><br><br><br><br><img src='assets/textures/editor/disconnect.png' width=500 height=375 draggable=false></img></div>"},200);
          var start = new editor.Window(350, 150, 525, 100, "Integrated server");
          start.windowContents.innerHTML = "<br><br><br><div style='margin-left: 30%'>Console window <input type=checkbox checked id='console_enabled'></div><br><button onclick='document.getElementById(`testIframe`).src = `index.html?integrated_server=true&server_copy_client_map=true&noconsole=`+!document.getElementById(`console_enabled`).checked; document.getElementById(`testIframe`).onload=function(){document.getElementById(`testIframe`).contentWindow.loadMap(JSON.stringify(editor.SAVE(3).map, function (k,v){if(v==-Infinity){return `-Infinity`};if(v==Infinity){return `Infinity`};return v}))}; this.parentElement.parentElement.children[0].children[0].click();' style='margin-left: 30%; height: 32px;'><h4 style='margin-top: 8px;'>start integrated server</h4></button>";
        }
        
        //set mode to map
        editor.setMode("map");
        
        //prepare tools
        editor.hideTool = true;
        new editor.tools.classes.MoveTool().initialize();
        new editor.tools.classes.RotateTool().initialize();
        new editor.tools.classes.ScaleTool().initialize();
        
        //create default objects
        editor.createObject(new THREE.Vector3(0, -2, 0)).scale.set(50,1,50);
        var spawnPoint = editor.createObject(false, "spawn");
        [spawnPoint.INVISIBLE,spawnPoint.COLLIDABLE,spawnPoint.unHittable] = [true, false, true];
        
        //start mainloop
        editor.mainLoop();
      }
      
      //initialize on page load
      onload = editor.initialize;
    </script>
  </body>
</html>